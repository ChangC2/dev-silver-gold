/***************************************************************************
 This example demonstrates how to display and update a GLG realtime
 stripchart widget and use its integrated interactive behavior.

 GlgChart class is derived from GlgJBean and encapsulates methods
 for initializing the chart, updating the chart with data and handling
 user interaction.

 GlgChart loads and displays a drawing passed as an argument to the
 LoadDrawing() method. It is expected that the drawing includes a
 viewport named ChartViewport as well as interface widgets allowing
 to scroll and zoom the chart. ChartViewport contains the Chart object
 which plots the chart data.

 The chart is initilaized in the H and V callbacks and updated with
 data supplied by the DataFeed using a timer. The demo uses DemoDataFeed
 to generate simulated data. The application will provide a custom
 data feed implementation via LiveDataFeed class. Both DemoDataFeed
 and LiveDataFeed implement DataFeedInterface.

 The X axis labels display current date and time using the time format
 defined in the drawing. Data points in the chart are positioned according
 to their time stamp. An application may provide a time stamp for each
 data point, otherwise the chart will automatically use current time for
 the time stamp.

 This example is written using GLG Intermediate API.
 ***************************************************************************/

package GLG;

import Model.HSTFileReadManager;
import Model.HSTFileSaveManager;
import Utils.PreferenceManager;
import com.genlogic.*;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.util.ArrayList;

//////////////////////////////////////////////////////////////////////////
public class GlgHSTChart extends GlgJLWBean implements ActionListener {
    static final long serialVersionUID = 0;

    /* RandomData is set to true to use simulated data for animation,
       and false for live real-time data. In the demo, RandomData is assigned
       by the parent container, using RANDOM_DATA flag or command
       line option -random-data or live-data.
     */
    public boolean RandomData = false;

    // Parent container.
    GlgHSTChartView ParentContainer;

    /* If set to true, the application supplies time stamp for each data
       sample explicitly in DataFeed.GetPlotPoint(). Otherwise, time stamp
       is automatically generated by the chart using current time.
    */
    public boolean SUPPLY_TIME_STAMP = false;

    // Chart orientation - HORIZONTAL or VERTICAL.
    int ChartOrientation;

    // DataFeed object is used to supply data for animation.
    DataFeedInterface DataFeed;

    Timer timer = null;                // Timer for periodic updates.
    int UpdateInterval = 100;          // Update interval in msec.

    // Number of lines and Y axes in a chart as defined in the drawing.
    int NumPlots;
    int NumYAxes;

    GlgObject ChartVP;    // ChartViewport
    GlgObject Chart;      // Chart object inside ChartViewport

    /* Store object IDs for each plot.
       Used for performance optimization to update the chart with data.
    */
    GlgObject[] Plots;

    /* Store Low and High ranges of each Y axis in the drawing.
       It is assumed that each plot is linked to a Y axis in the drawing,
       so the plot's  Low and High is set automatically based on
       the linked Y axis.
    */
    double[] Low;
    double[] High;
    double[] Target;

    boolean IsReady = false;

    /* Convenient time span constants. */
    static final int ONE_MINUTE = 60;
    static final int ONE_HOUR = 3600;
    static final int ONE_DAY = 3600 * 24;

    /* Constants for scrolling to the beginning or the end of the time range. */
    static final int DONT_CHANGE = 0;
    static final int MOST_RECENT = 1;    /* Make the most recent data visible. */
    static final int LEAST_RECENT = 2;   /* Make the least recent data visible.*/

    /* Prefill time interval, specifies amount of data to prefill in the
       real time chart.
    */
    final int PREFILL_SPAN = ONE_HOUR * 8;

    final int TIME_SPAN = ONE_MINUTE;          /* Time axis span in sec. */
    final double SCROLL_INCREMENT = 10.;       /* Scroll increment in sec. */
    final int INIT_SPAN = 0;                   /* Index of the initial span
                                                 to display.*/

    // Scroll factor for the X axis.
    final double ScrollFactor = SCROLL_INCREMENT / TIME_SPAN;

    boolean PrefillData = false;     /* Setting to False suppresses pre-filling
                                      the  chart's buffer with data
                                      on start-up. */
    int AutoScroll = 1;             /* Current auto-scroll state: enabled(1) or
                                      disabled(0). */
    int StoredScrollState;          /* Stored AutoScroll state to be restored
                                      if ZoomTo is aborted. */

    int TimeSpan = TIME_SPAN;       /* Current X axis span. */
    int SpanIndex = INIT_SPAN;      /* Currently selected index in the
                                      SpanSelector menu. */

    // Used by DataFeed to return data values.
    DataPoint data_point = new DataPoint();

    /////////////////////////////////////////////////////////////////////
    // Constructor.
    /////////////////////////////////////////////////////////////////////
    public GlgHSTChart(GlgHSTChartView parent) {
        ParentContainer = parent;

      /* Activate Trace callback. In this example, it is used
         to activate chart scrolling by dragging it with the mouse.
      */
        AddListener(GlgObject.TRACE_CB, this);

      /* Disable automatic update for input events to avoid slowing down
         real-time chart updates.
      */
        SetAutoUpdateOnInput(false);
    }

    /////////////////////////////////////////////////////////////////////
    // Add DataFeed object for supplying chart data.
    /////////////////////////////////////////////////////////////////////
    public void AddDataFeed() {
        if (RandomData) {
            //DataFeed = new DemoDataFeed(this);
            error("Using DemoDataFeed.", false);
        } else {
            //DataFeed = new LiveDataFeed(this);
            error("Using LiveDataFeed.", false);
        }
    }

    //////////////////////////////////////////////////////////////////////
    // Load a specified GLG drawing.
    //////////////////////////////////////////////////////////////////////
    public void LoadDrawing(String drawing_name) {
        if (drawing_name == null) {
            System.out.println("No drawing file: drawing loading failed.");
            return;
        }

        SetDrawingName(drawing_name);
    }

    ////////////////////////////////////////////////////////////////////////
    // HCallback is invoked after the Glg drawing is loaded, but before the
    // hierarchy setup takes place and before the drawing is drawn for the
    // first time.
    ////////////////////////////////////////////////////////////////////////
    public void HCallback(GlgObject viewport) {
        ChartVP = viewport.GetResourceObject("ChartViewport");
        if (ChartVP == null)
            GlgObject.Error(GlgObject.USER_ERROR,
                    "Can't find ChartViewport", null);

        Chart = ChartVP.GetResourceObject("Chart");
        if (Chart == null)
            GlgObject.Error(GlgObject.USER_ERROR,
                    "Can't find Chart object", null);

        // Retrieve the chart orientation, i.e. vertical or horizontal.
        ChartOrientation = Chart.GetDResource("Orientation").intValue();

        // Retrieve number of plots defined in .g file.
        // * We update plots because we added new plot for current sequence number
        boolean update = Chart.SetDResource("NumPlots", 9);
        NumPlots = Chart.GetDResource("NumPlots").intValue();

        // Retrieve number of Y axes defined in .g file.
        NumYAxes = Chart.GetDResource("NumYAxes").intValue();

        // Set Time Span for the X axis.
        Chart.SetDResource("XAxis/Span", TIME_SPAN);

        // Enable AutoScroll, both for the toggle button and the chart.
        ChangeAutoScroll(1);

        // Set Chart Zoom mode. It was set and saved with the drawing,
        // but do it again programmatically just in case.
        //
        ChartVP.SetZoomMode(null, Chart, null, GlgObject.CHART_ZOOM_MODE);

        ChartVP.SetSResource("Title/String", "HST Data View");

        // Show the Legend Titles
        ChartVP.SetDResource("Legend/Visibility", 1);
        ChartVP.SetDResource("Legend/Label/Visibility", 1);
    }

    //////////////////////////////////////////////////////////////////////
    // VCallback() is invoked after the drawing is loaded and setup,
    // but before it is drawn for the first time.
    /////////////////////////////////////////////////////////////////////
    public void VCallback(GlgObject viewport) {
        int i;

        // Store objects IDs for each plot.
        Plots = new GlgObject[NumPlots];

        GlgObject plot_array = Chart.GetResourceObject("Plots");
        for (i = 0; i < NumPlots; ++i) {
            Plots[i] = (GlgObject) plot_array.GetElement(i);

            switch (i) {
                case 0:
                    // Target
                    Plots[i].SetGResource("EdgeColor", 124, 252, 0); //Green
                    Plots[i].SetDResource("LineWidth", PreferenceManager.getLineWidth());
                    //Plots[i].SetSResource("Annotation","Target");
                    break;
                case 1:
                    // High
                    Plots[i].SetGResource("EdgeColor", 255, 0, 0); //RED
                    //Plots[i].SetSResource("Annotation","High");
                    Plots[i].SetDResource("LineWidth", PreferenceManager.getLineWidth());
                    break;
                case 2:
                    // Wear
                    Plots[i].SetGResource("EdgeColor", 255, 165, 0); //ORANGE
                    //Plots[i].SetSResource("Annotation","Wear");
                    Plots[i].SetDResource("LineWidth", PreferenceManager.getLineWidth());
                    break;
                case 3:
                    // Low Limit Timer and not used now
                    Plots[i].SetGResource("EdgeColor", 0, 191, 255); //BLUE
                    //Plots[i].SetSResource("Annotation","Low");
                    Plots[i].SetDResource("LineWidth", PreferenceManager.getLineWidth());
                    break;
                case 4:
                    // HP
                    Plots[i].SetGResource("EdgeColor", 138, 43, 226); //PURPLE
                    //Plots[i].SetSResource("Annotation","HP");
                    Plots[i].SetDResource("LineWidth", PreferenceManager.getLineWidth());
                    break;
                case 5:
                    Plots[i].SetGResource("EdgeColor", 100, 70, 36); /// BROWN // LEAD IN TRIGGER
                    Plots[i].SetDResource("LineType", 17);
                    Plots[i].SetDResource("LineWidth", PreferenceManager.getLineWidth());
                    break;
                case 6:
                    Plots[i].SetGResource("EdgeColor", 255, 255, 255); /// WHITE
                    //Plots[i].SetSResource("Annotation","IDLE");
                    Plots[i].SetDResource("LineWidth", PreferenceManager.getLineWidth());
                    break;

                case 7:
                    Plots[i].SetGResource("EdgeColor", 0, 128, 128); /// TEAL // ADAPTIVE
                    Plots[i].SetDResource("LineType", 17);
                    Plots[i].SetDResource("LineWidth", PreferenceManager.getLineWidth());
                    break;
                case 8:
                    Plots[i].SetGResource("EdgeColor", 255,192,203); /// pink // Current Sequence Num
                    Plots[i].SetDResource("LineWidth", PreferenceManager.getLineWidth());
                    Plots[i].SetSResource("Annotation","Current Seq N");
                    Plots[i].SetSResource("PlotAnnotation","Current Seq N");
                    break;
            }
        }

      /* Store initial range for each Y axis, used to restore ranges
         on zoom reset. Assumes that each plot is linked to the
         corresponding axis in the drawing.
      */
        Low = new double[NumYAxes];
        High = new double[NumYAxes];
        Target = new double[NumYAxes];

        GlgObject axis_array = Chart.GetResourceObject("YAxisGroup");
        for (i = 0; i < NumYAxes; ++i) {
            GlgObject axis = (GlgObject) axis_array.GetElement(i);
            Low[i] = axis.GetDResource("Low").doubleValue();
            High[i] = axis.GetDResource("High").doubleValue();
            //Target[i] = axis.GetDResource("Target").doubleValue();
        }
    }

    ////////////////////////////////////////////////////////////////////////
    // ReadyCallback is invoked after the drawing is loaded, setup and
    // initially drawn.
    ////////////////////////////////////////////////////////////////////////
    public void ReadyCallback(GlgObject viewport) {
        IsReady = true;


        /* Add DataFeed object used to supply chart data.
        The example uses demo data. To supply application specific
        data, replace DemoDataFeed with a custom LiveDataFeed.
        */
        AddDataFeed();

        // Prefill chart's history buffer with data.
        if (PrefillData) {
            FillChartHistory();
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Supply Plots Data, invoked by user interface
    //////////////////////////////////////////////////////////////////////
    public void supplyNewPlots(float[] plotsData) {

        if (!IsReady)
            return;

        if (plotsData == null)
            return;

        int validPlots = Math.min(plotsData.length, NumPlots);

        // Update plot lines with new data supplied by the DataFeed object.
        for (int i = 0; i < validPlots; ++i) {

            data_point.value = plotsData[i];
            data_point.value_valid = true;

            if (SUPPLY_TIME_STAMP) {
                // Supply time stamp explicitly.
                data_point.time_stamp = GetCurrTime();
            } else {
                // Chart will automatically supply time stamp using current time.
                data_point.time_stamp = 0.;
            }

            PushPlotPoint(Plots[i], data_point);
        }

        Update(); // Refresh display.
    }

    HSTFileReadManager hstReadManager;

    public void showHSTData(HSTFileReadManager hstReadManager) {
        this.hstReadManager = hstReadManager;

        if (!IsReady) {
            return;
        }

        // Clear Data Buffer
        for (int i = 0; i < NumPlots; ++i) {
            Plots[i].ClearDataBuffer(null);
        }

        int validPlotNums = Math.min(NumPlots, hstReadManager.getNumsOfVar());
        ArrayList<DataPoint> dataPoints = hstReadManager.getPlotData();
        while (dataPoints != null) {
            for (int i = 0; i < validPlotNums; ++i) {

                FillPlotData(Plots[i], dataPoints.get(i));
            }

            dataPoints = hstReadManager.getPlotData();
        }

        ScrollToDataEnd(MOST_RECENT, true);

        Update();
    }

    ///////////////////////////////////////////////////////////////////////
    // ActionListener for timer, invoked periodically with
    // time interval = UpdateInterval.
    //////////////////////////////////////////////////////////////////////
    public void actionPerformed(ActionEvent e) {
        if (timer == null)
            return;                 // Prevents race conditions.

        UpdateChart();              // Update the chart with nre data.

        timer.start();              // Restart the timer.
    }

    ///////////////////////////////////////////////////////////////////////
    // Push new data values to all lines in the chart.
    // Invoked periodically by timer with time interval defined by
    // UpdateInterval.
    ///////////////////////////////////////////////////////////////////////
    public void UpdateChart() {
      /* Perform dynamic updates only if the drawing is ready and
         the timer is active.
      */
        if (!IsReady)
            return;

        ArrayList<Double> plotValues = new ArrayList<>();

        // Update plot lines with new data supplied by the DataFeed object.
        for (int i = 0; i < NumPlots; ++i) {
            /* Use DataFeed to get new data value. The DataFeed object
                fills the data_point object with value, time_stamp, etc.
            */
            if (DataFeed.GetPlotPoint(i, data_point)) {
                PushPlotPoint(Plots[i], data_point);

                plotValues.add(data_point.value);
            } else {
                error("Error getting plot data sample.", false);
            }
        }

        Update(); // Refresh display.

    }

    ///////////////////////////////////////////////////////////////////////
    // Pushes the data_point's data into the plot.
    ///////////////////////////////////////////////////////////////////////
    public void PushPlotPoint(GlgObject plot, DataPoint data_point) {
        // Supply plot value for the chart via ValueEntryPoint.
        plot.SetDResource("ValueEntryPoint", data_point.value);

        if (data_point.time_stamp != 0) {
         /* Supply an optional time stamp. If not supplied, the chart will
            automatically generate a time stamp using current time.
         */
            plot.SetDResource("TimeEntryPoint", data_point.time_stamp);
        }

        if (!data_point.value_valid) {
         /* If the data point is not valid, set ValidEntryPoint resource to
            display holes for invalid data points. If the point is valid,
            it is automatically set to 1. by the chart.
         */
            plot.SetDResource("ValidEntryPoint", 0.);
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Pre-fill the graph's history buffer with data.
    ///////////////////////////////////////////////////////////////////////
    public void FillChartHistory() {
        double current_time = GetCurrTime();

        /* Fill the amount of data requested by the PREFILL_SPAN, up to the
        available chart's buffer size defined in the drawing.
        Add an extra second to avoid rounding errors.
        */
        int num_seconds = PREFILL_SPAN + 1;

        int buffer_size = Chart.GetDResource("BufferSize").intValue();
        if (buffer_size < 1)
            buffer_size = 1;

        int max_num_samples;
        if (RandomData) {
            /* In random demo data mode, simulate data stored once per second. */
            double samples_per_second = 1.0;
            max_num_samples = (int) (num_seconds * samples_per_second);

            if (max_num_samples > buffer_size)
                max_num_samples = buffer_size;
        } else
            max_num_samples = buffer_size;

        double start_time = current_time - num_seconds;
        double end_time = current_time;   /* Stop at the current time. */

        for (int i = 0; i < NumPlots; ++i) {
            ArrayList<DataPoint> data_array =
                    DataFeed.GetHistPlotData(i, start_time, end_time,
                            max_num_samples);

            if (data_array == null || data_array.isEmpty()) {
                error("No historical data for plot_index = " + i, false);
                continue;
            }

            FillPlotData(Plots[i], data_array);
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Fills plot with data from the provided data array.
    // For increased performance of prefilling a chart with large quantities
    // of data, use low level API functions.
    ///////////////////////////////////////////////////////////////////////
    public void FillPlotData(GlgObject plot,
                             ArrayList<DataPoint> data_array) {
        int size = data_array.size();
        for (int i = 0; i < size; ++i) {
            DataPoint data_point = data_array.get(i);

            GlgDataSampleNode node = GlgObject.CreateDataSampleNode(plot, false);
            GlgDataSample datasample = node.GetNodeDataSample();
            datasample.value = data_point.value;
            datasample.time = data_point.time_stamp;
            datasample.valid = data_point.value_valid;
            datasample.marker_vis = 0.f;

            // Using quick mode to speed-up prefilling of the chart.
            plot.AddDataSampleNode(node, /*quick mode*/ true);
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Fills plot with data from the provided data item.
    // For increased performance of prefilling a chart with large quantities
    // of data, use low level API functions.
    ///////////////////////////////////////////////////////////////////////
    public void FillPlotData(GlgObject plot, DataPoint data_point) {
        GlgDataSampleNode node = GlgObject.CreateDataSampleNode(plot, false);
        GlgDataSample datasample = node.GetNodeDataSample();
        datasample.value = data_point.value;
        datasample.time = data_point.time_stamp;
        datasample.valid = data_point.value_valid;
        datasample.marker_vis = 0.f;

        // Using quick mode to speed-up prefilling of the chart.
        plot.AddDataSampleNode(node, /*quick mode*/ true);
    }

    ///////////////////////////////////////////////////////////////////////
    // Handle user interaction.
    ///////////////////////////////////////////////////////////////////////
    public void InputCallback(GlgObject viewport, GlgObject message_obj) {
        String
                origin,
                format,
                action,
                subaction;

        origin = message_obj.GetSResource("Origin");
        format = message_obj.GetSResource("Format");
        action = message_obj.GetSResource("Action");
        subaction = message_obj.GetSResource("SubAction");

        // Handle window closing if run stand-alone.
        if (format.equals("Window") && action.equals("DeleteWindow"))
            System.exit(0);

        // Process button events.
        if (format.equals("Button")) {
            if (!action.equals("Activate") &&      /* Not a push button */
                    !action.equals("ValueChanged"))   /* Not a toggle button */
                return;

            AbortZoomTo();

            if (origin.equals("ToggleAutoScroll")) {
                // Set Chart AutoScroll based on the
                // ToggleAutoScroll toggle button setting.
                ChangeAutoScroll(-1);
            } else if (origin.equals("ZoomTo")) {
                // Start ZoomTo operation.
                ChartVP.SetZoom(null, 't', 0.);
            } else if (origin.equals("ZoomReset")) {
                // Set initial time span and reset initial Y ranges.
                SetChartSpan(SpanIndex);
                RestoreInitialYRanges();
            } else if (origin.equals("ScrollBack")) {
                ChangeAutoScroll(0);

            /* Scroll left (horizontal chart) or scroll down (vertical chart).
               Scrolling can be done by either setting chart's
               XAxis/EndValue resource or by using GlgSetZoom().
            */

            /* double end_value;
               double end_value =
                   Chart.GetDResource( "XAxis/EndValue" );
               end_value -= SCROLL_INCREMENT;
               Chart.SetDResource( "XAxis/EndValue", end_value );
            */

                switch (ChartOrientation) {
                    case GlgObject.HORIZONTAL:
                    default:
                        ChartVP.SetZoom(null, 'l', ScrollFactor);
                        break;
                    case GlgObject.VERTICAL:
                        ChartVP.SetZoom(null, 'd', ScrollFactor);
                        break;
                }
            } else if (origin.equals("ScrollForward")) {
                ChangeAutoScroll(0);

                switch (ChartOrientation) {
                    case GlgObject.HORIZONTAL:
                    default:
                        // Scroll right.
                        ChartVP.SetZoom(null, 'r', ScrollFactor);
                        break;
                    case GlgObject.VERTICAL:
                        // Scroll up.
                        ChartVP.SetZoom(null, 'u', ScrollFactor);
                        break;
                }
            } else if (origin.equals("ScrollBack2")) {
                ChangeAutoScroll(0);

                /* Scroll left by a full span. */
                switch (ChartOrientation) {
                    case GlgObject.HORIZONTAL:
                    default:
                        ChartVP.SetZoom(null, 'l', 1.);
                        break;
                    case GlgObject.VERTICAL:
                        ChartVP.SetZoom(null, 'd', 1.);
                        break;
                }

            } else if (origin.equals("ScrollForward2")) {
                ChangeAutoScroll(0);

                switch (ChartOrientation) {
                    case GlgObject.HORIZONTAL:
                    default:
                        // Scroll right by a full span.
                        ChartVP.SetZoom(null, 'r', 1.);
                        break;
                    case GlgObject.VERTICAL:
                        // Scroll up by a full span.
                        ChartVP.SetZoom(null, 'u', 1.);
                        break;
                }
            } else if (origin.equals("ScrollToRecent")) {
                // Scroll to show most recent data.
                ScrollToDataEnd(MOST_RECENT, true);
            }

            Update();
        } else if (format.equals("Chart") &&
                action.equals("CrossHairUpdate")) {
         /* To avoid slowing down real-time chart updates, invoke Update()
            to redraw cross-hair only if the chart is not updated fast
            enough by the timer.
         */
            if (UpdateInterval > 100)
                Update();
        } else if (action.equals("Zoom")) { // Zoom events

            if (subaction.equals("ZoomRectangle")) {
                // Store AutoSCroll state to restore it if ZoomTo is aborted.
                StoredScrollState = AutoScroll;

                // Stop scrolling when ZoomTo action is started.
                ChangeAutoScroll(0);
            } else if (subaction.equals("End")) {
            /* No additional actions on finishing ZoomTo. The Value axis
               scrollbar appears automatically if needed:
               it is set to PAN_Y_AUTO for a horizontal chart
               and PAN_X_AUTO for a vertical chart.
               Don't resume scrolling: it'll scroll too fast since we zoomed
               in. Keep it still to allow inspecting zoomed data.
            */
            } else if (subaction.equals("Abort")) {
                // Resume scrolling if it was on.
                ChangeAutoScroll(StoredScrollState);
            }

            Update();
        } else if (action.equals("Pan")) {  // Pan events
            // This code may be used to perform custom action when dragging the
            // chart's data with the mouse.
            if (subaction.equals("Start")) {                // Chart dragging start

            } else if (subaction.equals("Drag")) {          // Dragging

            } else if (subaction.equals("ValueChanged")) {  // Scrollbars

            }
            /* Dragging ended or aborted. */
            else if (subaction.equals("End") || subaction.equals("Abort")) {

            }
        } else if (format.equals("Option")) {
         /* Handle events from the SpanSelector combobox, allowing to select time
            span on the X axis.
         */

            if (!action.equals("Select"))
                return;

            /* Abort ZoomTo mode, if any. */
            AbortZoomTo();

            if (origin.equals("SpanSelector"))    /* Span change */ {
                SpanIndex =
                        message_obj.GetDResource("SelectedIndex").intValue();

                SetChartSpan(SpanIndex);

                /* Restore ranges in case the chart was zoomed.*/
                RestoreInitialYRanges();

            /* Scroll to show the recent data to avoid showing an empty chart
               if user scrolls too much into the future or into the past.

               Invoke ScrollToDataEnd() even if AutoScroll is GlgTrue to
               scroll ahead by a few extra seconds to show a few next updates
               without scrolling the chart.
            */
                GlgMinMax min_max =
                        Chart.GetChartDataExtent(null, /*x extent*/ true,
                                /*query all samples*/ false);

                if (min_max != null) {
                    double first_time_stamp = min_max.min;
                    double last_time_stamp = min_max.max;
                    double displayed_time_end =
                            Chart.GetDResource("XAxis/EndValue").doubleValue();

                    if (AutoScroll != 0)
                        ScrollToDataEnd(MOST_RECENT, true);

                    else if (displayed_time_end >
                            last_time_stamp + GetExtraSeconds(TimeSpan))
                        ScrollToDataEnd(MOST_RECENT, true);

                    else if (displayed_time_end - TimeSpan <= first_time_stamp)
                        ScrollToDataEnd(LEAST_RECENT, true);

                    Update();
                }
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Scroll to the end of the data history buffer.
    ///////////////////////////////////////////////////////////////////////
    public void ScrollToDataEnd(int data_end, boolean show_extra) {
        if (data_end == DONT_CHANGE)
            return;

        GlgMinMax min_max =
                Chart.GetChartDataExtent(null, /*x extent*/ true,
                        /*query all samples*/ false);
        if (min_max == null)
            return;

        double end_value, extra_sec;
        if (show_extra)
            extra_sec = GetExtraSeconds(TimeSpan);
        else
            extra_sec = 0.0;

        if (data_end == MOST_RECENT)
            end_value = min_max.max + extra_sec;
        else   /* LEAST_RECENT */
            end_value = min_max.min - extra_sec + TimeSpan;

        Chart.SetDResource("XAxis/EndValue", end_value);
    }

    ///////////////////////////////////////////////////////////////////////
    // Change chart's AutoScroll mode.
    ///////////////////////////////////////////////////////////////////////
    public void ChangeAutoScroll(int new_value) {
        if (new_value == -1)  // Use the state of the ToggleAutoScroll button.
        {
            double auto_scroll =
                    GetDResource("Toolbar/ToggleAutoScroll/OnState");
            AutoScroll = (int) auto_scroll;
        } else    // Set to the supplied value.
        {
            AutoScroll = new_value;
            SetDResource("Toolbar/ToggleAutoScroll/OnState",
                    (double) AutoScroll);
        }

        // Set chart's auto-scroll.
        Chart.SetDResource("AutoScroll", (double) AutoScroll);

      /* Activate time scrollbar if AutoScroll is Off. The Value scrollbar
         uses PAN_Y_AUTO (horizontal chart) or PAN_X_AUTO (vertical chart)
         and appears automatically as needed.
      */
        int pan_time_axis, pan_value_axis;
        switch (ChartOrientation) {
            case GlgObject.HORIZONTAL:
            default:
                pan_time_axis = GlgObject.PAN_X;
                pan_value_axis = GlgObject.PAN_Y_AUTO;
                break;
            case GlgObject.VERTICAL:
                pan_time_axis = GlgObject.PAN_Y;
                pan_value_axis = GlgObject.PAN_X_AUTO;
                break;
        }

        pan_time_axis = (AutoScroll != 0 ? GlgObject.NO_PAN : pan_time_axis);

        // To remove the scroller, we disable this code and use value NO_PAN(0)
        //ChartVP.SetDResource("Pan", (double) (pan_time_axis | pan_value_axis));
        ChartVP.SetDResource("Pan", (double) 0);
    }

    ///////////////////////////////////////////////////////////////////////
    // Changes the time span shown in the graph.
    ///////////////////////////////////////////////////////////////////////
    public void SetChartSpan(int span_index) {
        if (!HasResourceObject("Toolbar/SpanSelector"))
            return;

        int span, major_interval, minor_interval;

        /* Change chart's time span, as well as major and minor tick intervals.*/
        switch (span_index) {
            default:
            case 0:
                span = ONE_MINUTE;
                major_interval = 10;  /* major tick every 10 sec. */
                minor_interval = 1;   /* minor tick every sec. */
                break;

            case 1:
                span = 10 * ONE_MINUTE;
                major_interval = ONE_MINUTE * 2; /* major tick every tow minutes. */
                minor_interval = 30;             /* minor tick every 30 sec. */
                break;

            case 2:
                span = ONE_HOUR;
                major_interval = ONE_MINUTE * 10; /* major tick every 10 min. */
                minor_interval = ONE_MINUTE;      /* minor tick every min. */
                break;

            case 3:
                span = ONE_HOUR * 8;
                major_interval = ONE_HOUR;        /* major tick every hour. */
                minor_interval = ONE_MINUTE * 15; /* minor tick every 15 minutes. */
                break;
        }

        /* Update the menu in the drawing with the initial value if different. */
        SetDResource("Toolbar/SpanSelector/SelectedIndex", (double) span_index,
                true);

        /* Set intervals. */
        Chart.SetDResource("XAxis/MajorInterval", (double) major_interval);
        Chart.SetDResource("XAxis/MinorInterval", (double) minor_interval);

      /* Set the time span on the X axis, which controls how much data get
         displayed.
      */
        TimeSpan = span;
        Chart.SetDResource("XAxis/Span", (double) TimeSpan);

        /* Turn on data filtering for large spans. */
        for (int i = 0; i < NumPlots; ++i) {
            if (span_index > 1) {
            /* Agregate multiple data samples to minimize a number of data points
               drawn per each horizontal FilterPrecision interval.
               Show only one set of MIN/MAX values per each pixel interval.
               An averaging data filter is also available.
            */
                Plots[i].SetDResource("FilterType",
                        (double) GlgObject.MIN_MAX_FILTER);
                Plots[i].SetDResource("FilterPrecision", 1.);
            } else
                Plots[i].SetDResource("FilterType",
                        (double) GlgObject.NULL_FILTER);
        }

        /* Change time and tooltip formatting to match the selected span. */
        SetTimeFormats();
    }

    ///////////////////////////////////////////////////////////////////////
    // Sets the formats of time labels and tooltips depending on the selected
    // time span.
    ///////////////////////////////////////////////////////////////////////
    public void SetTimeFormats() {
        String
                time_label_format,
                time_tooltip_format,
                chart_tooltip_format;

      /* No additional code is required to use the defaults defined in the
         drawing. The code below illustrates advanced options for
         customizing label and tooltip formatting when switching between
         time spans and data display modes.

         For an even greater control over labels and tooltips, an application
         can define custom Label and Tooltip formatters that will supply
         custom strings for axis labels and tooltips.
      */

      /* Different time formats are used depending on the selected
         time span. See strftime() for all time format options.
      */
        switch (SpanIndex) {
            default:  /* 1 minute and 10 minutes spans */
         /* Use the preferred time and date display format for the current
            locale. */
                time_label_format = "%X%n%x";
                break;

            case 2: /* 1 hour span */
         /* Use the 12 hour time display with no seconds, and the default
            date display format for the current locale.
         */
                time_label_format = "%I:%M %p%n%x";
                break;

            case 3: /* 1 hour and 8 hour spans */
                /* Use 24 hour notation and don't display seconds. */
                time_label_format = "%H:%M%n%x";
                break;
        }

        Chart.SetSResource("XAxis/TimeFormat", time_label_format);

      /* Specify axis and chart tooltip format, if different from default
         formats defined in the drawing.
      */
        time_tooltip_format =
                "Time: <axis_time:%X> +0.<axis_time_ms:%03.0lf> sec.\nDate: <axis_time:%x>";

        /* <sample_time:%s> inherits time format from the X axis. */
        chart_tooltip_format =
                "Plot <plot_string:%s> value= <sample_y:%.2lf>\n<sample_time:%s>";

        /* Set time label and tooltip formats. */
        Chart.SetSResource("XAxis/TooltipFormat", time_tooltip_format);
        Chart.SetSResource("TooltipFormat", chart_tooltip_format);
    }

    ///////////////////////////////////////////////////////////////////////
    // Restore Y axis range to the initial Low/High values.
    ///////////////////////////////////////////////////////////////////////
    public void RestoreInitialYRanges() {
        GlgObject axis_array = Chart.GetResourceObject("YAxisGroup");
        for (int i = 0; i < NumYAxes; ++i) {
            GlgObject axis = (GlgObject) axis_array.GetElement(i);
            axis.SetDResource("Low", Low[i]);
            axis.SetDResource("High", High[i]);
            //axis.SetDResource("Target", Target[i]);
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Returns True if the chart's viewport is in ZoomToMode.
    // ZoomToMode is activated on Dragging and ZoomTo operations.
    ///////////////////////////////////////////////////////////////////////
    public boolean ZoomToMode() {
        int zoom_mode = ChartVP.GetDResource("ZoomToMode").intValue();
        return (zoom_mode != 0);
    }

    ///////////////////////////////////////////////////////////////////////
    // Abort ZoomTo mode.
    ///////////////////////////////////////////////////////////////////////
    public void AbortZoomTo() {
        if (ZoomToMode()) {
            // Abort zoom mode in progress.
            ChartVP.SetZoom(null, 'e', 0.);
            Update();
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Used to obtain coordinates of the mouse click.
    ///////////////////////////////////////////////////////////////////////
    public void TraceCallback(GlgObject viewport, GlgTraceData trace_info) {
        if (!IsReady)
            return;

        // Process only events that occur in ChartVP.
        if (trace_info.viewport != ChartVP)
            return;

        int event_type = trace_info.event.getID();
        switch (event_type) {
            case MouseEvent.MOUSE_PRESSED:
            case MouseEvent.MOUSE_MOVED:
            case MouseEvent.MOUSE_DRAGGED:
         /* The code to get the mouse coordinates if needed:
            x = ((MouseEvent)trace_info.event).getX();
            y = ((MouseEvent)trace_info.event).getY();
         */
                break;

            default:
                return;
        }

        switch (event_type) {
            case MouseEvent.MOUSE_PRESSED:
                if (ZoomToMode())
                    return; // ZoomTo or dragging mode in progress.

         /* Start dragging with the mouse on a mouse click.
            If user clicked of an axis, the dragging will be activated in the
            direction of that axis. If the user clicked in the chart area,
            dragging in both the time and the Y direction will be activated.
         */
                ChartVP.SetZoom(null, 's', 0.);

                // Disable AutoScroll not to interfere with dragging.
                ChangeAutoScroll(0);
                break;

            default:
                return;
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Return exact time including fractions of seconds.
    ///////////////////////////////////////////////////////////////////////
    public double GetCurrTime() {
        return System.currentTimeMillis() / 1000.;
    }

    ///////////////////////////////////////////////////////////////////////
    // Determines a good number of extra seconds to be added at the end in
    // the real-time mode to show a few next updates without scrolling the
    // chart.
    ///////////////////////////////////////////////////////////////////////
    public double GetExtraSeconds(int time_span) {
        double extra_sec = time_span * 0.1;
        double max_extra_sec = (time_span > ONE_HOUR ? 5. : 3.);

        if (extra_sec > max_extra_sec)
            extra_sec = max_extra_sec;

        return extra_sec;
    }

    ///////////////////////////////////////////////////////////////////////
    void error(String string, boolean quit) {
        System.out.println(string + "ER2");
        if (quit)
            System.exit(0);
    }

    //////////////////////////////////////////////////////////////////////////
    // Invoked by the browser asynchronously to stop the applet.
    // This method is provided in case the class is used as an applet;
    // it is not used when it is used as a bean in a parent applet in this
    // example.
    //////////////////////////////////////////////////////////////////////////
    public void stop() {

        // GlgJBean handles asynchronous invocation when used as an applet.
        super.stop();
    }
}
